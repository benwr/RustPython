exec('\n"""Access to Python\'s configuration information."""\n\nimport os\nimport sys\nfrom os.path import pardir, realpath\n\n__all__ = [\n    \'get_config_h_filename\',\n    \'get_config_var\',\n    \'get_config_vars\',\n    \'get_makefile_filename\',\n    \'get_path\',\n    \'get_path_names\',\n    \'get_paths\',\n    \'get_platform\',\n    \'get_python_version\',\n    \'get_scheme_names\',\n    \'parse_config_h\',\n]\n\n# Keys for get_config_var() that are never converted to Python integers.\n_ALWAYS_STR = {\n    \'MACOSX_DEPLOYMENT_TARGET\',\n}\n\n_INSTALL_SCHEMES = {\n    \'posix_prefix\': {\n        \'stdlib\': \'{installed_base}/{platlibdir}/python{py_version_short}\',\n        \'platstdlib\': \'{platbase}/{platlibdir}/python{py_version_short}\',\n        \'purelib\': \'{base}/lib/python{py_version_short}/site-packages\',\n        \'platlib\': \'{platbase}/{platlibdir}/python{py_version_short}/site-packages\',\n        \'include\':\n            \'{installed_base}/include/python{py_version_short}{abiflags}\',\n        \'platinclude\':\n            \'{installed_platbase}/include/python{py_version_short}{abiflags}\',\n        \'scripts\': \'{base}/bin\',\n        \'data\': \'{base}\',\n        },\n    \'posix_home\': {\n        \'stdlib\': \'{installed_base}/lib/python\',\n        \'platstdlib\': \'{base}/lib/python\',\n        \'purelib\': \'{base}/lib/python\',\n        \'platlib\': \'{base}/lib/python\',\n        \'include\': \'{installed_base}/include/python\',\n        \'platinclude\': \'{installed_base}/include/python\',\n        \'scripts\': \'{base}/bin\',\n        \'data\': \'{base}\',\n        },\n    \'nt\': {\n        \'stdlib\': \'{installed_base}/Lib\',\n        \'platstdlib\': \'{base}/Lib\',\n        \'purelib\': \'{base}/Lib/site-packages\',\n        \'platlib\': \'{base}/Lib/site-packages\',\n        \'include\': \'{installed_base}/Include\',\n        \'platinclude\': \'{installed_base}/Include\',\n        \'scripts\': \'{base}/Scripts\',\n        \'data\': \'{base}\',\n        },\n    # Downstream distributors can overwrite the default install scheme.\n    # This is done to support downstream modifications where distributors change\n    # the installation layout (eg. different site-packages directory).\n    # So, distributors will change the default scheme to one that correctly\n    # represents their layout.\n    # This presents an issue for projects/people that need to bootstrap virtual\n    # environments, like virtualenv. As distributors might now be customizing\n    # the default install scheme, there is no guarantee that the information\n    # returned by sysconfig.get_default_scheme/get_paths is correct for\n    # a virtual environment, the only guarantee we have is that it is correct\n    # for the *current* environment. When bootstrapping a virtual environment,\n    # we need to know its layout, so that we can place the files in the\n    # correct locations.\n    # The "*_venv" install scheme is a scheme to bootstrap virtual environments,\n    # essentially identical to the default posix_prefix/nt schemes.\n    # Downstream distributors who patch posix_prefix/nt scheme are encouraged to\n    # leave the following schemes unchanged\n    \'posix_venv\': {\n        \'stdlib\': \'{installed_base}/{platlibdir}/python{py_version_short}\',\n        \'platstdlib\': \'{platbase}/{platlibdir}/python{py_version_short}\',\n        \'purelib\': \'{base}/lib/python{py_version_short}/site-packages\',\n        \'platlib\': \'{platbase}/{platlibdir}/python{py_version_short}/site-packages\',\n        \'include\':\n            \'{installed_base}/include/python{py_version_short}{abiflags}\',\n        \'platinclude\':\n            \'{installed_platbase}/include/python{py_version_short}{abiflags}\',\n        \'scripts\': \'{base}/bin\',\n        \'data\': \'{base}\',\n        },\n    \'nt_venv\': {\n        \'stdlib\': \'{installed_base}/Lib\',\n        \'platstdlib\': \'{base}/Lib\',\n        \'purelib\': \'{base}/Lib/site-packages\',\n        \'platlib\': \'{base}/Lib/site-packages\',\n        \'include\': \'{installed_base}/Include\',\n        \'platinclude\': \'{installed_base}/Include\',\n        \'scripts\': \'{base}/Scripts\',\n        \'data\': \'{base}\',\n        },\n    }\n\n# For the OS-native venv scheme, we essentially provide an alias:\nif os.name == \'nt\':\n    _INSTALL_SCHEMES[\'venv\'] = _INSTALL_SCHEMES[\'nt_venv\']\nelse:\n    _INSTALL_SCHEMES[\'venv\'] = _INSTALL_SCHEMES[\'posix_venv\']\n\n\n# NOTE: site.py has copy of this function.\n# Sync it when modify this function.\ndef _getuserbase():\n    env_base = os.environ.get("PYTHONUSERBASE", None)\n    if env_base:\n        return env_base\n\n    # Emscripten, VxWorks, and WASI have no home directories\n    if sys.platform in {"emscripten", "vxworks", "wasi"}:\n        return None\n\n    def joinuser(*args):\n        return os.path.expanduser(os.path.join(*args))\n\n    if os.name == "nt":\n        base = os.environ.get("APPDATA") or "~"\n        return joinuser(base, "Python")\n\n    if sys.platform == "darwin" and sys._framework:\n        return joinuser("~", "Library", sys._framework,\n                        f"{sys.version_info[0]}.{sys.version_info[1]}")\n\n    return joinuser("~", ".local")\n\n_HAS_USER_BASE = (_getuserbase() is not None)\n\nif _HAS_USER_BASE:\n    _INSTALL_SCHEMES |= {\n        # NOTE: When modifying "purelib" scheme, update site._get_path() too.\n        \'nt_user\': {\n            \'stdlib\': \'{userbase}/Python{py_version_nodot_plat}\',\n            \'platstdlib\': \'{userbase}/Python{py_version_nodot_plat}\',\n            \'purelib\': \'{userbase}/Python{py_version_nodot_plat}/site-packages\',\n            \'platlib\': \'{userbase}/Python{py_version_nodot_plat}/site-packages\',\n            \'include\': \'{userbase}/Python{py_version_nodot_plat}/Include\',\n            \'scripts\': \'{userbase}/Python{py_version_nodot_plat}/Scripts\',\n            \'data\': \'{userbase}\',\n            },\n        \'posix_user\': {\n            \'stdlib\': \'{userbase}/{platlibdir}/python{py_version_short}\',\n            \'platstdlib\': \'{userbase}/{platlibdir}/python{py_version_short}\',\n            \'purelib\': \'{userbase}/lib/python{py_version_short}/site-packages\',\n            \'platlib\': \'{userbase}/lib/python{py_version_short}/site-packages\',\n            \'include\': \'{userbase}/include/python{py_version_short}\',\n            \'scripts\': \'{userbase}/bin\',\n            \'data\': \'{userbase}\',\n            },\n        \'osx_framework_user\': {\n            \'stdlib\': \'{userbase}/lib/python\',\n            \'platstdlib\': \'{userbase}/lib/python\',\n            \'purelib\': \'{userbase}/lib/python/site-packages\',\n            \'platlib\': \'{userbase}/lib/python/site-packages\',\n            \'include\': \'{userbase}/include/python{py_version_short}\',\n            \'scripts\': \'{userbase}/bin\',\n            \'data\': \'{userbase}\',\n            },\n    }\n\n_SCHEME_KEYS = (\'stdlib\', \'platstdlib\', \'purelib\', \'platlib\', \'include\',\n                \'scripts\', \'data\')\n\n_PY_VERSION = sys.version.split()[0]\n_PY_VERSION_SHORT = f\'{sys.version_info[0]}.{sys.version_info[1]}\'\n_PY_VERSION_SHORT_NO_DOT = f\'{sys.version_info[0]}{sys.version_info[1]}\'\n_PREFIX = os.path.normpath(sys.prefix)\n_BASE_PREFIX = os.path.normpath(sys.base_prefix)\n_EXEC_PREFIX = os.path.normpath(sys.exec_prefix)\n_BASE_EXEC_PREFIX = os.path.normpath(sys.base_exec_prefix)\n_CONFIG_VARS = None\n_USER_BASE = None\n\n# Regexes needed for parsing Makefile (and similar syntaxes,\n# like old-style Setup files).\n_variable_rx = r"([a-zA-Z][a-zA-Z0-9_]+)\\s*=\\s*(.*)"\n_findvar1_rx = r"\\$\\(([A-Za-z][A-Za-z0-9_]*)\\)"\n_findvar2_rx = r"\\${([A-Za-z][A-Za-z0-9_]*)}"\n\n\ndef _safe_realpath(path):\n    try:\n        return realpath(path)\n    except OSError:\n        return path\n\nif sys.executable:\n    _PROJECT_BASE = os.path.dirname(_safe_realpath(sys.executable))\nelse:\n    # sys.executable can be empty if argv[0] has been changed and Python is\n    # unable to retrieve the real program name\n    _PROJECT_BASE = _safe_realpath(os.getcwd())\n\n# In a virtual environment, `sys._home` gives us the target directory\n# `_PROJECT_BASE` for the executable that created it when the virtual\n# python is an actual executable (\'venv --copies\' or Windows).\n_sys_home = getattr(sys, \'_home\', None)\nif _sys_home:\n    _PROJECT_BASE = _sys_home\n\nif os.name == \'nt\':\n    # In a source build, the executable is in a subdirectory of the root\n    # that we want (<root>\\PCbuild\\<platname>).\n    # `_BASE_PREFIX` is used as the base installation is where the source\n    # will be.  The realpath is needed to prevent mount point confusion\n    # that can occur with just string comparisons.\n    if _safe_realpath(_PROJECT_BASE).startswith(\n            _safe_realpath(f\'{_BASE_PREFIX}\\\\PCbuild\')):\n        _PROJECT_BASE = _BASE_PREFIX\n\n# set for cross builds\nif "_PYTHON_PROJECT_BASE" in os.environ:\n    _PROJECT_BASE = _safe_realpath(os.environ["_PYTHON_PROJECT_BASE"])\n\ndef is_python_build(check_home=None):\n    if check_home is not None:\n        import warnings\n        warnings.warn("check_home argument is deprecated and ignored.",\n                      DeprecationWarning, stacklevel=2)\n    for fn in ("Setup", "Setup.local"):\n        if os.path.isfile(os.path.join(_PROJECT_BASE, "Modules", fn)):\n            return True\n    return False\n\n_PYTHON_BUILD = is_python_build()\n\nif _PYTHON_BUILD:\n    for scheme in (\'posix_prefix\', \'posix_home\'):\n        # On POSIX-y platforms, Python will:\n        # - Build from .h files in \'headers\' (which is only added to the\n        #   scheme when building CPython)\n        # - Install .h files to \'include\'\n        scheme = _INSTALL_SCHEMES[scheme]\n        scheme[\'headers\'] = scheme[\'include\']\n        scheme[\'include\'] = \'{srcdir}/Include\'\n        scheme[\'platinclude\'] = \'{projectbase}/.\'\n    del scheme\n\n\ndef _subst_vars(s, local_vars):\n    try:\n        return s.format(**local_vars)\n    except KeyError as var:\n        try:\n            return s.format(**os.environ)\n        except KeyError:\n            raise AttributeError(f\'{var}\') from None\n\ndef _extend_dict(target_dict, other_dict):\n    target_keys = target_dict.keys()\n    for key, value in other_dict.items():\n        if key in target_keys:\n            continue\n        target_dict[key] = value\n\n\ndef _expand_vars(scheme, vars):\n    res = {}\n    if vars is None:\n        vars = {}\n    _extend_dict(vars, get_config_vars())\n    if os.name == \'nt\':\n        # On Windows we want to substitute \'lib\' for schemes rather\n        # than the native value (without modifying vars, in case it\n        # was passed in)\n        vars = vars | {\'platlibdir\': \'lib\'}\n\n    for key, value in _INSTALL_SCHEMES[scheme].items():\n        if os.name in (\'posix\', \'nt\'):\n            value = os.path.expanduser(value)\n        res[key] = os.path.normpath(_subst_vars(value, vars))\n    return res\n\n\ndef _get_preferred_schemes():\n    if os.name == \'nt\':\n        return {\n            \'prefix\': \'nt\',\n            \'home\': \'posix_home\',\n            \'user\': \'nt_user\',\n        }\n    if sys.platform == \'darwin\' and sys._framework:\n        return {\n            \'prefix\': \'posix_prefix\',\n            \'home\': \'posix_home\',\n            \'user\': \'osx_framework_user\',\n        }\n    return {\n        \'prefix\': \'posix_prefix\',\n        \'home\': \'posix_home\',\n        \'user\': \'posix_user\',\n    }\n\n\ndef get_preferred_scheme(key):\n    if key == \'prefix\' and sys.prefix != sys.base_prefix:\n        return \'venv\'\n    scheme = _get_preferred_schemes()[key]\n    if scheme not in _INSTALL_SCHEMES:\n        raise ValueError(\n            f"{key!r} returned {scheme!r}, which is not a valid scheme "\n            f"on this platform"\n        )\n    return scheme\n\n\ndef get_default_scheme():\n    return get_preferred_scheme(\'prefix\')\n\n\ndef _parse_makefile(filename, vars=None, keep_unresolved=True):\n    """Parse a Makefile-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    """\n    import re\n\n    if vars is None:\n        vars = {}\n    done = {}\n    notdone = {}\n\n    with open(filename, encoding=sys.getfilesystemencoding(),\n              errors="surrogateescape") as f:\n        lines = f.readlines()\n\n    for line in lines:\n        if line.startswith(\'#\') or line.strip() == \'\':\n            continue\n        m = re.match(_variable_rx, line)\n        if m:\n            n, v = m.group(1, 2)\n            v = v.strip()\n            # `$$\' is a literal `$\' in make\n            tmpv = v.replace(\'$$\', \'\')\n\n            if "$" in tmpv:\n                notdone[n] = v\n            else:\n                try:\n                    if n in _ALWAYS_STR:\n                        raise ValueError\n\n                    v = int(v)\n                except ValueError:\n                    # insert literal `$\'\n                    done[n] = v.replace(\'$$\', \'$\')\n                else:\n                    done[n] = v\n\n    # do variable interpolation here\n    variables = list(notdone.keys())\n\n    # Variables with a \'PY_\' prefix in the makefile. These need to\n    # be made available without that prefix through sysconfig.\n    # Special care is needed to ensure that variable expansion works, even\n    # if the expansion uses the name without a prefix.\n    renamed_variables = (\'CFLAGS\', \'LDFLAGS\', \'CPPFLAGS\')\n\n    while len(variables) > 0:\n        for name in tuple(variables):\n            value = notdone[name]\n            m1 = re.search(_findvar1_rx, value)\n            m2 = re.search(_findvar2_rx, value)\n            if m1 and m2:\n                m = m1 if m1.start() < m2.start() else m2\n            else:\n                m = m1 if m1 else m2\n            if m is not None:\n                n = m.group(1)\n                found = True\n                if n in done:\n                    item = str(done[n])\n                elif n in notdone:\n                    # get it on a subsequent round\n                    found = False\n                elif n in os.environ:\n                    # do it like make: fall back to environment\n                    item = os.environ[n]\n\n                elif n in renamed_variables:\n                    if (name.startswith(\'PY_\') and\n                        name[3:] in renamed_variables):\n                        item = ""\n\n                    elif \'PY_\' + n in notdone:\n                        found = False\n\n                    else:\n                        item = str(done[\'PY_\' + n])\n\n                else:\n                    done[n] = item = ""\n\n                if found:\n                    after = value[m.end():]\n                    value = value[:m.start()] + item + after\n                    if "$" in after:\n                        notdone[name] = value\n                    else:\n                        try:\n                            if name in _ALWAYS_STR:\n                                raise ValueError\n                            value = int(value)\n                        except ValueError:\n                            done[name] = value.strip()\n                        else:\n                            done[name] = value\n                        variables.remove(name)\n\n                        if name.startswith(\'PY_\') \\\n                        and name[3:] in renamed_variables:\n\n                            name = name[3:]\n                            if name not in done:\n                                done[name] = value\n\n            else:\n                # Adds unresolved variables to the done dict.\n                # This is disabled when called from distutils.sysconfig\n                if keep_unresolved:\n                    done[name] = value\n                # bogus variable reference (e.g. "prefix=$/opt/python");\n                # just drop it since we can\'t deal\n                variables.remove(name)\n\n    # strip spurious spaces\n    for k, v in done.items():\n        if isinstance(v, str):\n            done[k] = v.strip()\n\n    # save the results in the global dictionary\n    vars.update(done)\n    return vars\n\n\ndef get_makefile_filename():\n    """Return the path of the Makefile."""\n    if _PYTHON_BUILD:\n        return os.path.join(_PROJECT_BASE, "Makefile")\n    if hasattr(sys, \'abiflags\'):\n        config_dir_name = f\'config-{_PY_VERSION_SHORT}{sys.abiflags}\'\n    else:\n        config_dir_name = \'config\'\n    if hasattr(sys.implementation, \'_multiarch\'):\n        config_dir_name += f\'-{sys.implementation._multiarch}\'\n    return os.path.join(get_path(\'stdlib\'), config_dir_name, \'Makefile\')\n\n\ndef _get_sysconfigdata_name():\n    multiarch = getattr(sys.implementation, \'_multiarch\', \'\')\n    return os.environ.get(\n        \'_PYTHON_SYSCONFIGDATA_NAME\',\n        f\'_sysconfigdata_{sys.abiflags}_{sys.platform}_{multiarch}\',\n    )\n\n\ndef _generate_posix_vars():\n    """Generate the Python module containing build-time variables."""\n    import pprint\n    vars = {}\n    # load the installed Makefile:\n    makefile = get_makefile_filename()\n    try:\n        _parse_makefile(makefile, vars)\n    except OSError as e:\n        msg = f"invalid Python installation: unable to open {makefile}"\n        if hasattr(e, "strerror"):\n            msg = f"{msg} ({e.strerror})"\n        raise OSError(msg)\n    # load the installed pyconfig.h:\n    config_h = get_config_h_filename()\n    try:\n        with open(config_h, encoding="utf-8") as f:\n            parse_config_h(f, vars)\n    except OSError as e:\n        msg = f"invalid Python installation: unable to open {config_h}"\n        if hasattr(e, "strerror"):\n            msg = f"{msg} ({e.strerror})"\n        raise OSError(msg)\n    # On AIX, there are wrong paths to the linker scripts in the Makefile\n    # -- these paths are relative to the Python source, but when installed\n    # the scripts are in another directory.\n    if _PYTHON_BUILD:\n        vars[\'BLDSHARED\'] = vars[\'LDSHARED\']\n\n    # There\'s a chicken-and-egg situation on OS X with regards to the\n    # _sysconfigdata module after the changes introduced by #15298:\n    # get_config_vars() is called by get_platform() as part of the\n    # `make pybuilddir.txt` target -- which is a precursor to the\n    # _sysconfigdata.py module being constructed.  Unfortunately,\n    # get_config_vars() eventually calls _init_posix(), which attempts\n    # to import _sysconfigdata, which we won\'t have built yet.  In order\n    # for _init_posix() to work, if we\'re on Darwin, just mock up the\n    # _sysconfigdata module manually and populate it with the build vars.\n    # This is more than sufficient for ensuring the subsequent call to\n    # get_platform() succeeds.\n    name = _get_sysconfigdata_name()\n    if \'darwin\' in sys.platform:\n        import types\n        module = types.ModuleType(name)\n        module.build_time_vars = vars\n        sys.modules[name] = module\n\n    pybuilddir = f\'build/lib.{get_platform()}-{_PY_VERSION_SHORT}\'\n    if hasattr(sys, "gettotalrefcount"):\n        pybuilddir += \'-pydebug\'\n    os.makedirs(pybuilddir, exist_ok=True)\n    destfile = os.path.join(pybuilddir, name + \'.py\')\n\n    with open(destfile, \'w\', encoding=\'utf8\') as f:\n        f.write(\'# system configuration generated and used by\'\n                \' the sysconfig module\\n\')\n        f.write(\'build_time_vars = \')\n        pprint.pprint(vars, stream=f)\n\n    # Create file used for sys.path fixup -- see Modules/getpath.c\n    with open(\'pybuilddir.txt\', \'w\', encoding=\'utf8\') as f:\n        f.write(pybuilddir)\n\ndef _init_posix(vars):\n    """Initialize the module as appropriate for POSIX systems."""\n    # _sysconfigdata is generated at build time, see _generate_posix_vars()\n    name = _get_sysconfigdata_name()\n    _temp = __import__(name, globals(), locals(), [\'build_time_vars\'], 0)\n    build_time_vars = _temp.build_time_vars\n    vars.update(build_time_vars)\n\ndef _init_non_posix(vars):\n    """Initialize the module as appropriate for NT"""\n    # set basic install directories\n    import _imp\n    vars[\'LIBDEST\'] = get_path(\'stdlib\')\n    vars[\'BINLIBDEST\'] = get_path(\'platstdlib\')\n    vars[\'INCLUDEPY\'] = get_path(\'include\')\n    try:\n        # GH-99201: _imp.extension_suffixes may be empty when\n        # HAVE_DYNAMIC_LOADING is not set. In this case, don\'t set EXT_SUFFIX.\n        vars[\'EXT_SUFFIX\'] = _imp.extension_suffixes()[0]\n    except IndexError:\n        pass\n    vars[\'EXE\'] = \'.exe\'\n    vars[\'VERSION\'] = _PY_VERSION_SHORT_NO_DOT\n    vars[\'BINDIR\'] = os.path.dirname(_safe_realpath(sys.executable))\n    vars[\'TZPATH\'] = \'\'\n\n#\n# public APIs\n#\n\n\ndef parse_config_h(fp, vars=None):\n    """Parse a config.h-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    """\n    if vars is None:\n        vars = {}\n    import re\n    define_rx = re.compile("#define ([A-Z][A-Za-z0-9_]+) (.*)\\n")\n    undef_rx = re.compile("/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/\\n")\n\n    while True:\n        line = fp.readline()\n        if not line:\n            break\n        m = define_rx.match(line)\n        if m:\n            n, v = m.group(1, 2)\n            try:\n                if n in _ALWAYS_STR:\n                    raise ValueError\n                v = int(v)\n            except ValueError:\n                pass\n            vars[n] = v\n        else:\n            m = undef_rx.match(line)\n            if m:\n                vars[m.group(1)] = 0\n    return vars\n\n\ndef get_config_h_filename():\n    """Return the path of pyconfig.h."""\n    if _PYTHON_BUILD:\n        if os.name == "nt":\n            inc_dir = os.path.join(_PROJECT_BASE, "PC")\n        else:\n            inc_dir = _PROJECT_BASE\n    else:\n        inc_dir = get_path(\'platinclude\')\n    return os.path.join(inc_dir, \'pyconfig.h\')\n\n\ndef get_scheme_names():\n    """Return a tuple containing the schemes names."""\n    return tuple(sorted(_INSTALL_SCHEMES))\n\n\ndef get_path_names():\n    """Return a tuple containing the paths names."""\n    return _SCHEME_KEYS\n\n\ndef get_paths(scheme=get_default_scheme(), vars=None, expand=True):\n    """Return a mapping containing an install scheme.\n\n    ``scheme`` is the install scheme name. If not provided, it will\n    return the default scheme for the current platform.\n    """\n    if expand:\n        return _expand_vars(scheme, vars)\n    else:\n        return _INSTALL_SCHEMES[scheme]\n\n\ndef get_path(name, scheme=get_default_scheme(), vars=None, expand=True):\n    """Return a path corresponding to the scheme.\n\n    ``scheme`` is the install scheme name.\n    """\n    return get_paths(scheme, vars, expand)[name]\n\n\ndef get_config_vars(*args):\n    """With no arguments, return a dictionary of all configuration\n    variables relevant for the current platform.\n\n    On Unix, this means every variable defined in Python\'s installed Makefile;\n    On Windows it\'s a much smaller set.\n\n    With arguments, return a list of values that result from looking up\n    each argument in the configuration variable dictionary.\n    """\n    global _CONFIG_VARS\n    if _CONFIG_VARS is None:\n        _CONFIG_VARS = {}\n        # Normalized versions of prefix and exec_prefix are handy to have;\n        # in fact, these are the standard versions used most places in the\n        # Distutils.\n        _CONFIG_VARS[\'prefix\'] = _PREFIX\n        _CONFIG_VARS[\'exec_prefix\'] = _EXEC_PREFIX\n        _CONFIG_VARS[\'py_version\'] = _PY_VERSION\n        _CONFIG_VARS[\'py_version_short\'] = _PY_VERSION_SHORT\n        _CONFIG_VARS[\'py_version_nodot\'] = _PY_VERSION_SHORT_NO_DOT\n        _CONFIG_VARS[\'installed_base\'] = _BASE_PREFIX\n        _CONFIG_VARS[\'base\'] = _PREFIX\n        _CONFIG_VARS[\'installed_platbase\'] = _BASE_EXEC_PREFIX\n        _CONFIG_VARS[\'platbase\'] = _EXEC_PREFIX\n        _CONFIG_VARS[\'projectbase\'] = _PROJECT_BASE\n        _CONFIG_VARS[\'platlibdir\'] = sys.platlibdir\n        try:\n            _CONFIG_VARS[\'abiflags\'] = sys.abiflags\n        except AttributeError:\n            # sys.abiflags may not be defined on all platforms.\n            _CONFIG_VARS[\'abiflags\'] = \'\'\n        try:\n            _CONFIG_VARS[\'py_version_nodot_plat\'] = sys.winver.replace(\'.\', \'\')\n        except AttributeError:\n            _CONFIG_VARS[\'py_version_nodot_plat\'] = \'\'\n\n        if os.name == \'nt\':\n            _init_non_posix(_CONFIG_VARS)\n            _CONFIG_VARS[\'VPATH\'] = sys._vpath\n        if os.name == \'posix\':\n            _init_posix(_CONFIG_VARS)\n        if _HAS_USER_BASE:\n            # Setting \'userbase\' is done below the call to the\n            # init function to enable using \'get_config_var\' in\n            # the init-function.\n            _CONFIG_VARS[\'userbase\'] = _getuserbase()\n\n        # Always convert srcdir to an absolute path\n        srcdir = _CONFIG_VARS.get(\'srcdir\', _PROJECT_BASE)\n        if os.name == \'posix\':\n            if _PYTHON_BUILD:\n                # If srcdir is a relative path (typically \'.\' or \'..\')\n                # then it should be interpreted relative to the directory\n                # containing Makefile.\n                base = os.path.dirname(get_makefile_filename())\n                srcdir = os.path.join(base, srcdir)\n            else:\n                # srcdir is not meaningful since the installation is\n                # spread about the filesystem.  We choose the\n                # directory containing the Makefile since we know it\n                # exists.\n                srcdir = os.path.dirname(get_makefile_filename())\n        _CONFIG_VARS[\'srcdir\'] = _safe_realpath(srcdir)\n\n        # OS X platforms require special customization to handle\n        # multi-architecture, multi-os-version installers\n        if sys.platform == \'darwin\':\n            import _osx_support\n            _osx_support.customize_config_vars(_CONFIG_VARS)\n\n    if args:\n        vals = []\n        for name in args:\n            vals.append(_CONFIG_VARS.get(name))\n        return vals\n    else:\n        return _CONFIG_VARS\n\n\ndef get_config_var(name):\n    """Return the value of a single variable using the dictionary returned by\n    \'get_config_vars()\'.\n\n    Equivalent to get_config_vars().get(name)\n    """\n    return get_config_vars().get(name)\n\n\ndef get_platform():\n    """Return a string that identifies the current platform.\n\n    This is used mainly to distinguish platform-specific build directories and\n    platform-specific built distributions.  Typically includes the OS name and\n    version and the architecture (as supplied by \'os.uname()\'), although the\n    exact information included depends on the OS; on Linux, the kernel version\n    isn\'t particularly important.\n\n    Examples of returned values:\n       linux-i586\n       linux-alpha (?)\n       solaris-2.6-sun4u\n\n    Windows will return one of:\n       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n       win32 (all others - specifically, sys.platform is returned)\n\n    For other non-POSIX platforms, currently just returns \'sys.platform\'.\n\n    """\n    if os.name == \'nt\':\n        if \'amd64\' in sys.version.lower():\n            return \'win-amd64\'\n        if \'(arm)\' in sys.version.lower():\n            return \'win-arm32\'\n        if \'(arm64)\' in sys.version.lower():\n            return \'win-arm64\'\n        return sys.platform\n\n    if os.name != "posix" or not hasattr(os, \'uname\'):\n        # XXX what about the architecture? NT is Intel or Alpha\n        return sys.platform\n\n    # Set for cross builds explicitly\n    if "_PYTHON_HOST_PLATFORM" in os.environ:\n        return os.environ["_PYTHON_HOST_PLATFORM"]\n\n    # Try to distinguish various flavours of Unix\n    osname, host, release, version, machine = os.uname()\n\n    # Convert the OS name to lowercase, remove \'/\' characters, and translate\n    # spaces (for "Power Macintosh")\n    osname = osname.lower().replace(\'/\', \'\')\n    machine = machine.replace(\' \', \'_\')\n    machine = machine.replace(\'/\', \'-\')\n\n    if osname[:5] == "linux":\n        # At least on Linux/Intel, \'machine\' is the processor --\n        # i386, etc.\n        # XXX what about Alpha, SPARC, etc?\n        return  f"{osname}-{machine}"\n    elif osname[:5] == "sunos":\n        if release[0] >= "5":           # SunOS 5 == Solaris 2\n            osname = "solaris"\n            release = f"{int(release[0]) - 3}.{release[2:]}"\n            # We can\'t use "platform.architecture()[0]" because a\n            # bootstrap problem. We use a dict to get an error\n            # if some suspicious happens.\n            bitness = {2147483647:"32bit", 9223372036854775807:"64bit"}\n            machine += f".{bitness[sys.maxsize]}"\n        # fall through to standard osname-release-machine representation\n    elif osname[:3] == "aix":\n        from _aix_support import aix_platform\n        return aix_platform()\n    elif osname[:6] == "cygwin":\n        osname = "cygwin"\n        import re\n        rel_re = re.compile(r\'[\\d.]+\')\n        m = rel_re.match(release)\n        if m:\n            release = m.group()\n    elif osname[:6] == "darwin":\n        import _osx_support\n        osname, release, machine = _osx_support.get_platform_osx(\n                                            get_config_vars(),\n                                            osname, release, machine)\n\n    return f"{osname}-{release}-{machine}"\n\n\ndef get_python_version():\n    return _PY_VERSION_SHORT\n\n\ndef expand_makefile_vars(s, vars):\n    """Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in\n    \'string\' according to \'vars\' (a dictionary mapping variable names to\n    values).  Variables not present in \'vars\' are silently expanded to the\n    empty string.  The variable values in \'vars\' should not contain further\n    variable expansions; if \'vars\' is the output of \'parse_makefile()\',\n    you\'re fine.  Returns a variable-expanded version of \'s\'.\n    """\n    import re\n\n    # This algorithm does multiple expansion, so if vars[\'foo\'] contains\n    # "${bar}", it will expand ${foo} to ${bar}, and then expand\n    # ${bar}... and so forth.  This is fine as long as \'vars\' comes from\n    # \'parse_makefile()\', which takes care of such expansions eagerly,\n    # according to make\'s variable expansion semantics.\n\n    while True:\n        m = re.search(_findvar1_rx, s) or re.search(_findvar2_rx, s)\n        if m:\n            (beg, end) = m.span()\n            s = s[0:beg] + vars.get(m.group(1)) + s[end:]\n        else:\n            break\n    return s\n\n\ndef _print_dict(title, data):\n    for index, (key, value) in enumerate(sorted(data.items())):\n        if index == 0:\n            print(f\'{title}: \')\n        print(f\'\\t{key} = "{value}"\')\n\n\ndef _main():\n    """Display all information sysconfig detains."""\n    if \'--generate-posix-vars\' in sys.argv:\n        _generate_posix_vars()\n        return\n    print(f\'Platform: "{get_platform()}"\')\n    print(f\'Python version: "{get_python_version()}"\')\n    print(f\'Current installation scheme: "{get_default_scheme()}"\')\n    print()\n    _print_dict(\'Paths\', get_paths())\n    print()\n    _print_dict(\'Variables\', get_config_vars())\n\nif __name__ == \'__main__\':\n    _main()\n'.replace('Python','RustPython').replace('/python','/rustpython'))